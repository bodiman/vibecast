<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Framework Viewer - VibeCast</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
        }
        
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: #2a2a2a;
            border-bottom: 2px solid #ff6b35;
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
            gap: 20px;
        }
        
        .tribe-home {
            text-decoration: none;
            color: #ff6b35;
            font-size: 20px;
            font-weight: bold;
            transition: all 0.3s ease;
            cursor: pointer;
            margin-right: 20px;
        }
        
        .tribe-home:hover {
            color: #ff8555;
            transform: scale(1.05);
        }
        
        #header h1 {
            font-size: 18px;
            font-weight: 600;
            color: #e0e0e0;
        }
        
        #header .type-badge {
            padding: 4px 12px;
            background: #ff6b35;
            border-radius: 12px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: white;
        }
        
        #header .stats {
            margin-left: auto;
            display: flex;
            gap: 20px;
            font-size: 13px;
            color: #888;
        }
        
        #canvas-container {
            position: fixed;
            top: 60px;
            left: 0;
            right: 300px;
            bottom: 0;
            background: #1a1a1a;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        #sidebar {
            position: fixed;
            top: 60px;
            right: 0;
            width: 300px;
            bottom: 0;
            background: #2a2a2a;
            border-left: 2px solid #ff6b35;
            overflow-y: auto;
            padding: 20px;
        }
        
        #sidebar h2 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #fff;
        }
        
        #sidebar .node-info {
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        #sidebar .node-info h3 {
            font-size: 14px;
            margin-bottom: 8px;
            color: #ff6b35;
        }
        
        #sidebar .node-info .type {
            display: inline-block;
            padding: 2px 8px;
            background: #ff6b35;
            border-radius: 4px;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 10px;
            color: white;
        }
        
        #sidebar .node-info .content {
            font-size: 12px;
            line-height: 1.6;
            color: #aaa;
            margin-bottom: 10px;
        }
        
        #sidebar .meta {
            font-size: 11px;
            color: #666;
            margin-top: 8px;
        }
        
        #sidebar .connections {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }
        
        #sidebar .connection {
            font-size: 12px;
            padding: 5px 0;
            color: #888;
        }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: #8b5cf6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid #ef4444;
            border-radius: 8px;
            padding: 30px;
            max-width: 500px;
            text-align: center;
        }
        
        .legend {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
        }
        
        .legend h3 {
            font-size: 13px;
            margin-bottom: 10px;
            color: #aaa;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 0;
            font-size: 12px;
            color: #888;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }
        
        /* Edit Mode Controls */
        .edit-controls {
            margin-left: auto;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .edit-btn {
            background: #ff6b35;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .edit-btn:hover {
            background: #ff8555;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4);
        }
        
        .edit-btn:active {
            transform: translateY(0);
        }
        
        .edit-btn.active {
            background: #8b5cf6;
        }
        
        .save-status {
            font-size: 12px;
            color: #888;
            margin-left: 5px;
        }
        
        .save-status.saving {
            color: #ff6b35;
        }
        
        .save-status.saved {
            color: #10b981;
        }
        
        .save-status.error {
            color: #ef4444;
        }
        
        /* Edit Mode Styles */
        body.edit-mode #canvas {
            cursor: crosshair;
        }
        
        body.edit-mode .node-selected {
            cursor: move;
        }
        
        /* Edit Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        
        .modal.show {
            display: flex;
        }
        
        .modal-content {
            background: #2a2a2a;
            border: 2px solid #ff6b35;
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-header h2 {
            color: #fff;
            margin: 0;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-close:hover {
            color: #fff;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #e0e0e0;
            font-weight: 500;
        }
        
        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
        }
        
        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #ff6b35;
            box-shadow: 0 0 0 2px rgba(255, 107, 53, 0.2);
        }
        
        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }
        
        .form-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #3a3a3a;
        }
        
        .btn-primary {
            background: #ff6b35;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .btn-secondary {
            background: #3a3a3a;
            color: #e0e0e0;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .btn-primary:hover {
            background: #ff8555;
        }
        
        .btn-secondary:hover {
            background: #4a4a4a;
        }
        
        /* Context Menu */
        .context-menu {
            position: fixed;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            padding: 5px 0;
            min-width: 150px;
            z-index: 10000;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        
        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            color: #e0e0e0;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .context-menu-item:hover {
            background: #3a3a3a;
        }
        
        .context-menu-item.disabled {
            color: #666;
            cursor: not-allowed;
        }
        
        .context-menu-divider {
            height: 1px;
            background: #3a3a3a;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="header">
        <a href="/dashboard" class="tribe-home">🏠 Tribe</a>
        <h1 id="framework-name">Loading...</h1>
        <div class="type-badge" id="framework-type"></div>
        <div class="stats">
            <span id="node-count">0 nodes</span>
            <span id="edge-count">0 edges</span>
        </div>
        <div class="edit-controls">
            <button id="edit-mode-btn" class="edit-btn">📝 Edit</button>
            <button id="save-btn" class="edit-btn" style="display: none;">💾 Save</button>
            <span id="save-status" class="save-status"></span>
        </div>
    </div>
    
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
    
    <div id="sidebar">
        <h2>Details</h2>
        <div id="sidebar-content">
            <p style="color: #666; font-size: 13px;">Click a node to see details</p>
        </div>
        
        <div class="legend">
            <h3>Node Types</h3>
            <div id="legend-content"></div>
        </div>
        
        <div class="legend" style="margin-top: 15px;">
            <h3>Edge Types</h3>
            <div id="edge-legend-content"></div>
        </div>
    </div>
    
    <div id="loading" class="loading">
        <div class="spinner"></div>
        <div>Loading framework...</div>
    </div>

    <!-- Edit Modal -->
    <div id="edit-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">Edit Node</h2>
                <button class="modal-close" onclick="closeEditModal()">&times;</button>
            </div>
            <form id="edit-form">
                <div class="form-group">
                    <label for="edit-name">Name *</label>
                    <input type="text" id="edit-name" required>
                </div>
                <div class="form-group">
                    <label for="edit-type">Type</label>
                    <select id="edit-type">
                        <option value="scalar">Scalar</option>
                        <option value="series">Series</option>
                        <option value="parameter">Parameter</option>
                        <option value="concept">Concept</option>
                        <option value="entity">Entity</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="edit-description">Description</label>
                    <textarea id="edit-description" placeholder="Describe this node..."></textarea>
                </div>
                <div class="form-group">
                    <label for="edit-formula">Formula</label>
                    <textarea id="edit-formula" placeholder="e.g., REVENUE_GROWTH = REVENUE[0] - REVENUE[-1]"></textarea>
                    <small style="color: #888; font-size: 12px;">
                        <strong>Valid syntax:</strong> REVENUE - COST, REVENUE[0] - REVENUE[-1], sqrt(REVENUE) * 0.1<br>
                        <strong>Invalid syntax:</strong> =SUM(G9:G22), A1 + B2, AVERAGE(A1:A10)<br>
                        Use node identifiers (e.g., REVENUE, COST) to reference other nodes. Dependencies will be created automatically.
                    </small>
                </div>
                <div class="form-group">
                    <label for="edit-units">Units</label>
                    <input type="text" id="edit-units" placeholder="e.g., USD, %, units">
                </div>
                <div id="formula-validation" style="color: #ef4444; font-size: 12px; margin-top: 5px;"></div>
                <div class="form-actions">
                    <button type="button" class="btn-secondary" onclick="closeEditModal()">Cancel</button>
                    <button type="submit" class="btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Context Menu -->
    <div id="context-menu" class="context-menu">
        <div class="context-menu-item" onclick="addNode(contextMenuPosition.x, contextMenuPosition.y)">
            ➕ Add Node
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" onclick="editSelectedItem()">
            ✏️ Edit
        </div>
        <div class="context-menu-item" onclick="deleteSelectedItem()">
            🗑️ Delete
        </div>
    </div>

    <script>
        // Parse framework name from URL
        const pathParts = window.location.pathname.split('/').filter(p => p && p !== 'framework');
        const frameworkName = decodeURIComponent(pathParts.join('/')) || 'unknown';
        
        let framework = null;
        let selectedNode = null;
        let selectedEdge = null;
        let hoveredEdge = null;
        
        // Edit mode state
        let isEditMode = false;
        let editedNodes = new Map(); // Track changes for auto-save
        let editedEdges = new Map();
        let autoSaveTimeout = null;
        let contextMenuPosition = { x: 0, y: 0 };
        let currentEditItem = null; // Currently being edited in modal
        
        // Edge creation state
        let isCreatingEdge = false;
        let edgeCreationStart = null;
        
        // Canvas state
        let canvas, ctx;
        let camera = { x: 0, y: 0, zoom: 1 };
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        
        // Node colors by type (dark theme with orange accents)
        const nodeColors = {
            // Mathematical
            'parameter': '#ff6b35',
            'series': '#ff8555',
            'scalar': '#ffa075',
            // Knowledge
            'concept': '#ff6b35',
            'pattern': '#ff8555',
            'gotcha': '#ef4444',
            'tool': '#ffa075',
            'decision': '#ff6b35',
            'example': '#ff8555',
            'insight': '#ffa075',
            // Workflow
            'stage': '#ff6b35',
            'task': '#ff8555',
            // Default
            'default': '#ff6b35'
        };
        
        async function loadFramework() {
            try {
                const response = await fetch(`/api/frameworks/${encodeURIComponent(frameworkName)}/graph`);
                if (!response.ok) throw new Error(`Failed to load: ${response.statusText}`);
                
                framework = await response.json();
                
                // Debug: Log the data structure to verify transformation
                console.log('🔍 Framework loaded:', {
                    name: framework.name,
                    nodeCount: framework.nodes.length,
                    edgeCount: framework.edges.length,
                    sampleNode: framework.nodes[0],
                    sampleEdge: framework.edges[0],
                    nodeIds: framework.nodes.map(n => n.id),
                    edgeReferences: framework.edges.map(e => ({ id: e.id, source: e.source, target: e.target })),
                    nodePositions: framework.nodes.map(n => ({ id: n.id, name: n.name, position: n.position }))
                });
                
                // Specific edge validation
                if (framework.edges.length === 0) {
                    console.warn('⚠️ No edges found in framework - this may explain why no edges are rendering');
                } else {
                    console.log(`🔗 Found ${framework.edges.length} edges to render`);
                    
                    // Check if all edges have valid source/target references
                    const invalidEdges = framework.edges.filter(edge => {
                        const sourceExists = framework.nodes.some(n => n.id === edge.source);
                        const targetExists = framework.nodes.some(n => n.id === edge.target);
                        return !sourceExists || !targetExists;
                    });
                    
                    if (invalidEdges.length > 0) {
                        console.error('❌ Found edges with invalid node references:', invalidEdges);
                    } else {
                        console.log('✅ All edges have valid node references');
                    }
                }
                
                document.getElementById('framework-name').textContent = framework.name;
                document.getElementById('framework-type').textContent = framework.type;
                document.getElementById('node-count').textContent = `${framework.nodeCount} nodes`;
                document.getElementById('edge-count').textContent = `${framework.edgeCount} edges`;
                document.getElementById('loading').style.display = 'none';
                
                initCanvas();
                createLegend();
                
            } catch (error) {
                document.getElementById('loading').innerHTML = `
                    <div class="error">
                        <h2>Error Loading Framework</h2>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }
        
        function applyForceDirectedLayout() {
            const iterations = 80;
            const repulsionStrength = 2000; // Much stronger repulsion for better spacing
            const attractionStrength = 0.01; // Weaker attraction for looser layout
            const damping = 0.8;
            const minDistance = 300; // Larger minimum distance between nodes
            
            for (let iter = 0; iter < iterations; iter++) {
                // Apply repulsion between all nodes
                for (let i = 0; i < framework.nodes.length; i++) {
                    const nodeA = framework.nodes[i];
                    
                    for (let j = i + 1; j < framework.nodes.length; j++) {
                        const nodeB = framework.nodes[j];
                        
                        const dx = nodeB.position.x - nodeA.position.x;
                        const dy = nodeB.position.y - nodeA.position.y;
                        const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                        
                        if (distance < minDistance * 2) {
                            const force = repulsionStrength / (distance * distance + 1);
                            const fx = (dx / distance) * force * 0.01;
                            const fy = (dy / distance) * force * 0.01;
                            
                            nodeA.velocity.x -= fx;
                            nodeA.velocity.y -= fy;
                            nodeB.velocity.x += fx;
                            nodeB.velocity.y += fy;
                        }
                    }
                }
                
                // Apply attraction along edges
                framework.edges.forEach(edge => {
                    const source = framework.nodes.find(n => n.id === edge.source);
                    const target = framework.nodes.find(n => n.id === edge.target);
                    
                    if (source && target) {
                        const dx = target.position.x - source.position.x;
                        const dy = target.position.y - source.position.y;
                        const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                        
                        const force = distance * attractionStrength;
                        const fx = (dx / distance) * force;
                        const fy = (dy / distance) * force;
                        
                        source.velocity.x += fx;
                        source.velocity.y += fy;
                        target.velocity.x -= fx;
                        target.velocity.y -= fy;
                    }
                });
                
                // Update positions with damping
                framework.nodes.forEach(node => {
                    node.position.x += node.velocity.x;
                    node.position.y += node.velocity.y;
                    node.velocity.x *= damping;
                    node.velocity.y *= damping;
                });
            }
            
            // Reset velocities but keep slight random motion for dynamics
            framework.nodes.forEach(node => {
                node.velocity = { 
                    x: (Math.random() - 0.5) * 0.3, 
                    y: (Math.random() - 0.5) * 0.3 
                };
            });
        }
        
        function createLegend() {
            const types = [...new Set(framework.nodes.map(n => n.type))];
            const legendContent = document.getElementById('legend-content');
            
            legendContent.innerHTML = types.map(type => `
                <div class="legend-item">
                    <div class="legend-color" style="background: ${nodeColors[type] || nodeColors.default}"></div>
                    <span>${type}</span>
                </div>
            `).join('');
            
            // Create edge legend
            const edgeTypes = [...new Set(framework.edges.map(e => e.type).filter(t => t))];
            const edgeLegendContent = document.getElementById('edge-legend-content');
            
            if (edgeTypes.length > 0) {
                edgeLegendContent.innerHTML = edgeTypes.map(type => `
                    <div class="legend-item">
                        <div style="width: 20px; height: 2px; background: #666; margin: 7px 0;"></div>
                        <span>${type}</span>
                    </div>
                `).join('');
            } else {
                edgeLegendContent.innerHTML = '<div style="color: #666; font-size: 11px;">No edge types found</div>';
            }
        }
        
        function initCanvas() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Initialize node positions with force-directed layout
            let nodesNeedingPosition = 0;
            framework.nodes.forEach((node, i) => {
                // Only create new positions for nodes that truly don't have position data
                // Check for null, undefined, or completely missing position object
                if (!node.position || (node.position.x === undefined && node.position.y === undefined)) {
                    nodesNeedingPosition++;
                    // Start with a wider spiral to avoid initial overlap
                    const angle = (i / framework.nodes.length) * Math.PI * 2;
                    const spiralRadius = 150 + (i * 80); // Tighter spiral for better initial layout
                    node.position = {
                        x: Math.cos(angle) * spiralRadius + (Math.random() - 0.5) * 30,
                        y: Math.sin(angle) * spiralRadius + (Math.random() - 0.5) * 30,
                        z: 0
                    };
                    console.log(`🔄 Creating spiral position for node ${node.name}: (${Math.round(node.position.x)}, ${Math.round(node.position.y)})`);
                } else {
                    console.log(`✅ Using stored position for node ${node.name}: (${Math.round(node.position.x)}, ${Math.round(node.position.y)})`);
                }
                // Initialize velocity for physics simulation
                node.velocity = { x: 0, y: 0 };
            });
            
            console.log(`📍 Position initialization: ${nodesNeedingPosition} nodes needed new positions, ${framework.nodes.length - nodesNeedingPosition} used stored positions`);
            
            // Apply force-directed layout
            applyForceDirectedLayout();
            
            // Center camera
            centerCamera();
            
            // Event listeners
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onWheel, { passive: false });
            canvas.addEventListener('click', onClick);
            canvas.addEventListener('dblclick', onDoubleClick);
            canvas.addEventListener('contextmenu', onRightClick);
            canvas.addEventListener('mousemove', onMouseMoveHover);
            
            // Start rendering
            animate();
        }
        
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            canvas.height = canvas.offsetHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        
        function centerCamera() {
            if (!framework.nodes.length) return;
            
            const bounds = {
                minX: Infinity, maxX: -Infinity,
                minY: Infinity, maxY: -Infinity
            };
            
            framework.nodes.forEach(node => {
                bounds.minX = Math.min(bounds.minX, node.position.x);
                bounds.maxX = Math.max(bounds.maxX, node.position.x);
                bounds.minY = Math.min(bounds.minY, node.position.y);
                bounds.maxY = Math.max(bounds.maxY, node.position.y);
            });
            
            camera.x = -(bounds.minX + bounds.maxX) / 2;
            camera.y = -(bounds.minY + bounds.maxY) / 2;
            
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            const canvasWidth = canvas.offsetWidth;
            const canvasHeight = canvas.offsetHeight;
            
            camera.zoom = Math.min(canvasWidth / (width + 200), canvasHeight / (height + 200), 2);
        }
        
        function worldToScreen(x, y) {
            return {
                x: (x + camera.x) * camera.zoom + canvas.offsetWidth / 2,
                y: (y + camera.y) * camera.zoom + canvas.offsetHeight / 2
            };
        }
        
        function screenToWorld(x, y) {
            return {
                x: (x - canvas.offsetWidth / 2) / camera.zoom - camera.x,
                y: (y - canvas.offsetHeight / 2) / camera.zoom - camera.y
            };
        }
        
        function onMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const world = screenToWorld(x, y);
            
            // Check if clicking on a node in edit mode
            if (isEditMode && e.shiftKey) {
                const clickedNode = framework.nodes.find(node => {
                    const dx = node.position.x - world.x;
                    const dy = node.position.y - world.y;
                    return Math.sqrt(dx * dx + dy * dy) < 25 / camera.zoom;
                });
                
                if (clickedNode) {
                    // Start edge creation
                    isCreatingEdge = true;
                    edgeCreationStart = clickedNode;
                    canvas.style.cursor = 'crosshair';
                    return;
                }
            }
            
            isDragging = true;
            dragStart = { x: e.clientX, y: e.clientY };
        }
        
        function onMouseMove(e) {
            if (isDragging) {
                const dx = e.clientX - dragStart.x;
                const dy = e.clientY - dragStart.y;
                camera.x += dx / camera.zoom;
                camera.y += dy / camera.zoom;
                dragStart = { x: e.clientX, y: e.clientY };
            }
        }
        
        function onMouseMoveHover(e) {
            if (isDragging) {
                onMouseMove(e);
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const world = screenToWorld(x, y);
            
            // Check for hovered edge
            const newHoveredEdge = framework.edges.find(edge => {
                const source = framework.nodes.find(n => n.id === edge.source);
                const target = framework.nodes.find(n => n.id === edge.target);
                if (!source || !target) return false;
                
                return isPointNearLine(world.x, world.y, source.position.x, source.position.y, target.position.x, target.position.y, 8 / camera.zoom);
            });
            
            if (newHoveredEdge !== hoveredEdge) {
                hoveredEdge = newHoveredEdge;
                canvas.style.cursor = hoveredEdge ? 'pointer' : 'grab';
            }
        }
        
        function onMouseUp(e) {
            if (isCreatingEdge && edgeCreationStart) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const world = screenToWorld(x, y);
                
                // Find target node
                const targetNode = framework.nodes.find(node => {
                    if (node.id === edgeCreationStart.id) return false; // Can't connect to self
                    const dx = node.position.x - world.x;
                    const dy = node.position.y - world.y;
                    return Math.sqrt(dx * dx + dy * dy) < 25 / camera.zoom;
                });
                
                if (targetNode) {
                    // Create new edge
                    const edgeId = `edge_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    const newEdge = {
                        id: edgeId,
                        source: edgeCreationStart.id,
                        target: targetNode.id,
                        type: 'dependency',
                        metadata: {
                            userCreated: true,
                            createdAt: new Date().toISOString()
                        }
                    };
                    
                    framework.edges.push(newEdge);
                    editedEdges.set(edgeId, newEdge);
                    scheduleAutoSave();
                    
                    console.log(`🔗 Created edge: ${edgeCreationStart.name} → ${targetNode.name}`);
                }
                
                // Reset edge creation state
                isCreatingEdge = false;
                edgeCreationStart = null;
                canvas.style.cursor = isEditMode ? 'crosshair' : 'grab';
            }
            
            isDragging = false;
        }
        
        function onWheel(e) {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            camera.zoom = Math.max(0.05, Math.min(5, camera.zoom * zoomFactor));
        }
        
        function onClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const world = screenToWorld(x, y);
            
            // Find clicked node
            const clickedNode = framework.nodes.find(node => {
                const dx = node.position.x - world.x;
                const dy = node.position.y - world.y;
                return Math.sqrt(dx * dx + dy * dy) < 25 / camera.zoom;
            });
            
            // Find clicked edge
            let clickedEdge = null;
            if (!clickedNode) {
                clickedEdge = framework.edges.find(edge => {
                    const source = framework.nodes.find(n => n.id === edge.source);
                    const target = framework.nodes.find(n => n.id === edge.target);
                    if (!source || !target) return false;
                    
                    return isPointNearLine(world.x, world.y, source.position.x, source.position.y, target.position.x, target.position.y, 8 / camera.zoom);
                });
            }
            
            if (clickedNode) {
                selectedNode = clickedNode;
                selectedEdge = null;
                showNodeDetails(clickedNode);
            } else if (clickedEdge) {
                selectedNode = null;
                selectedEdge = clickedEdge;
                showEdgeDetails(clickedEdge);
            } else {
                selectedNode = null;
                selectedEdge = null;
                document.getElementById('sidebar-content').innerHTML = 
                    '<p style="color: #666; font-size: 13px;">Click a node or edge to see details</p>';
            }
        }
        
        function onDoubleClick(e) {
            if (!isEditMode) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const world = screenToWorld(x, y);
            
            // Find double-clicked node
            const clickedNode = framework.nodes.find(node => {
                const dx = node.position.x - world.x;
                const dy = node.position.y - world.y;
                return Math.sqrt(dx * dx + dy * dy) < 25 / camera.zoom;
            });
            
            if (clickedNode) {
                editNode(clickedNode);
            } else {
                // Double-click empty space to add node
                addNode(e.clientX, e.clientY);
            }
        }
        
        function onRightClick(e) {
            e.preventDefault();
            
            if (!isEditMode) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const world = screenToWorld(x, y);
            
            // Find right-clicked item
            const clickedNode = framework.nodes.find(node => {
                const dx = node.position.x - world.x;
                const dy = node.position.y - world.y;
                return Math.sqrt(dx * dx + dy * dy) < 25 / camera.zoom;
            });
            
            const clickedEdge = framework.edges.find(edge => {
                const source = framework.nodes.find(n => n.id === (typeof edge.source === 'object' ? edge.source.nodeId || edge.source.id : edge.source));
                const target = framework.nodes.find(n => n.id === (typeof edge.target === 'object' ? edge.target.nodeId || edge.target.id : edge.target));
                if (!source || !target) return false;
                
                return isPointNearLine(world.x, world.y, source.position.x, source.position.y, target.position.x, target.position.y, 8 / camera.zoom);
            });
            
            if (clickedNode) {
                selectedNode = clickedNode;
                selectedEdge = null;
            } else if (clickedEdge) {
                selectedEdge = clickedEdge;
                selectedNode = null;
            } else {
                selectedNode = null;
                selectedEdge = null;
            }
            
            showContextMenu(e.clientX, e.clientY);
        }
        
        function isPointNearLine(px, py, x1, y1, x2, y2, threshold) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            if (length === 0) return false;
            
            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (length * length)));
            const projX = x1 + t * dx;
            const projY = y1 + t * dy;
            const distance = Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
            
            return distance < threshold;
        }
        
        function showEdgeDetails(edge) {
            const source = framework.nodes.find(n => n.id === edge.source);
            const target = framework.nodes.find(n => n.id === edge.target);
            
            let html = `
                <div class="node-info">
                    <h3>Edge: ${edge.id || 'Unnamed'}</h3>
                    <div class="type">${edge.type || 'connection'}</div>
                    <div class="meta">From: ${source?.name || edge.source}</div>
                    <div class="meta">To: ${target?.name || edge.target}</div>
            `;
            
            if (edge.description) {
                html += `<div class="content"><strong>Description:</strong> ${edge.description}</div>`;
            }
            
            if (edge.strength !== undefined) {
                html += `<div class="meta"><strong>Strength:</strong> ${Math.round(edge.strength * 100)}%</div>`;
            }
            
            if (edge.weight !== undefined) {
                html += `<div class="meta"><strong>Weight:</strong> ${edge.weight}</div>`;
            }
            
            if (edge.confidence !== undefined) {
                html += `<div class="meta"><strong>Confidence:</strong> ${Math.round(edge.confidence * 100)}%</div>`;
            }
            
            if (edge.lag !== undefined) {
                html += `<div class="meta"><strong>Time Lag:</strong> ${edge.lag}</div>`;
            }
            
            // Enhanced metadata display for edges
            if (edge.metadata) {
                const shownKeys = ['description', 'strength', 'weight', 'confidence', 'lag'];
                Object.keys(edge.metadata).forEach(key => {
                    if (!shownKeys.includes(key) && edge.metadata[key] !== undefined && edge.metadata[key] !== null) {
                        const value = typeof edge.metadata[key] === 'object' ? JSON.stringify(edge.metadata[key]) : String(edge.metadata[key]);
                        if (value.length < 100) {
                            html += `<div class="meta"><strong>${key}:</strong> ${value}</div>`;
                        }
                    }
                });
            }
            
            html += '</div>';
            
            document.getElementById('sidebar-content').innerHTML = html;
        }
        
        function showNodeDetails(node) {
            const inbound = framework.edges.filter(e => e.target === node.id);
            const outbound = framework.edges.filter(e => e.source === node.id);
            
            let html = `
                <div class="node-info">
                    <h3>${node.name}</h3>
                    <div class="type">${node.type}</div>
                    <div class="meta">ID: ${node.id}</div>
            `;
            
            // Enhanced metadata display
            if (node.metadata) {
                if (node.metadata.summary) {
                    html += `<div class="content"><strong>Summary:</strong> <em>${node.metadata.summary}</em></div>`;
                }
                if (node.metadata.content) {
                    html += `<div class="content"><strong>Content:</strong> ${node.metadata.content.substring(0, 300)}${node.metadata.content.length > 300 ? '...' : ''}</div>`;
                }
                if (node.metadata.description) {
                    html += `<div class="content"><strong>Description:</strong> ${node.metadata.description}</div>`;
                }
                if (node.metadata.formula) {
                    html += `<div class="content"><strong>Formula:</strong> <code style="background: #333; padding: 2px 4px; border-radius: 3px;">${node.metadata.formula}</code></div>`;
                    
                    // Show formula-generated dependencies
                    const formulaEdges = framework.edges.filter(e => 
                        e.target === node.id && 
                        e.metadata?.generatedFromFormula
                    );
                    
                    if (formulaEdges.length > 0) {
                        const dependencyEdges = formulaEdges.filter(e => e.type === 'dependency');
                        const temporalEdges = formulaEdges.filter(e => e.type === 'temporal');
                        
                        if (dependencyEdges.length > 0) {
                            html += `<div class="meta" style="color: #10b981; font-size: 11px;"><strong>📐 Dependencies:</strong> ${dependencyEdges.map(e => {
                                const source = framework.nodes.find(n => n.id === e.source);
                                return source?.name || e.source;
                            }).join(', ')}</div>`;
                        }
                        
                        if (temporalEdges.length > 0) {
                            html += `<div class="meta" style="color: #8b5cf6; font-size: 11px;"><strong>⏰ Temporal:</strong> ${temporalEdges.map(e => {
                                const source = framework.nodes.find(n => n.id === e.source);
                                const offset = e.metadata?.timeOffset || 0;
                                return `${source?.name || e.source}[${offset}]`;
                            }).join(', ')}</div>`;
                        }
                    }
                }
                if (node.metadata.values) {
                    const values = Array.isArray(node.metadata.values) ? node.metadata.values.slice(0, 10) : [node.metadata.values];
                    html += `<div class="meta"><strong>Values:</strong> ${values.join(', ')}${Array.isArray(node.metadata.values) && node.metadata.values.length > 10 ? '...' : ''}</div>`;
                }
                if (node.metadata.units) {
                    html += `<div class="meta"><strong>Units:</strong> ${node.metadata.units}</div>`;
                }
                if (node.metadata.importance !== undefined) {
                    html += `<div class="meta"><strong>Importance:</strong> ${Math.round(node.metadata.importance * 100)}%</div>`;
                }
                if (node.metadata.tags && Array.isArray(node.metadata.tags)) {
                    html += `<div class="meta"><strong>Tags:</strong> ${node.metadata.tags.join(', ')}</div>`;
                }
                
                // Show all other metadata keys
                const shownKeys = ['summary', 'content', 'description', 'formula', 'values', 'units', 'importance', 'tags'];
                Object.keys(node.metadata).forEach(key => {
                    if (!shownKeys.includes(key) && node.metadata[key] !== undefined && node.metadata[key] !== null) {
                        const value = typeof node.metadata[key] === 'object' ? JSON.stringify(node.metadata[key]) : String(node.metadata[key]);
                        if (value.length < 100) {
                            html += `<div class="meta"><strong>${key}:</strong> ${value}</div>`;
                        }
                    }
                });
            }
            
            // Position information
            if (node.position) {
                html += `<div class="meta"><strong>Position:</strong> (${Math.round(node.position.x)}, ${Math.round(node.position.y)})${node.position.z !== undefined ? ', ' + Math.round(node.position.z) : ''}</div>`;
            }
            
            html += '</div>';
            
            if (inbound.length > 0 || outbound.length > 0) {
                html += '<div class="connections">';
                if (inbound.length > 0) {
                    html += `<h3 style="font-size: 13px; margin-bottom: 8px; color: #aaa;">Incoming (${inbound.length})</h3>`;
                    inbound.forEach(edge => {
                        const source = framework.nodes.find(n => n.id === edge.source);
                        html += `<div class="connection">← ${source?.name || edge.source} (${edge.type})</div>`;
                    });
                }
                if (outbound.length > 0) {
                    html += `<h3 style="font-size: 13px; margin: 15px 0 8px; color: #aaa;">Outgoing (${outbound.length})</h3>`;
                    outbound.forEach(edge => {
                        const target = framework.nodes.find(n => n.id === edge.target);
                        html += `<div class="connection">→ ${target?.name || edge.target} (${edge.type})</div>`;
                    });
                }
                html += '</div>';
            }
            
            document.getElementById('sidebar-content').innerHTML = html;
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Debug: Log drawing attempt (only occasionally to avoid spam)
            if (Math.random() < 0.01) { // 1% chance to log
                console.log(`🎨 Drawing frame: ${framework.edges.length} edges, ${framework.nodes.length} nodes`);
            }
            
            // Draw edges
            let edgesRendered = 0;
            framework.edges.forEach((edge, index) => {
                // Safety check: Convert edge source/target to string if they're objects
                let sourceId = edge.source;
                let targetId = edge.target;
                
                if (typeof edge.source === 'object') {
                    console.error(`🚨 Edge ${edge.id} has object source:`, edge.source);
                    sourceId = edge.source?.nodeId || edge.source?.id || 'INVALID_SOURCE';
                }
                if (typeof edge.target === 'object') {
                    console.error(`🚨 Edge ${edge.id} has object target:`, edge.target);
                    targetId = edge.target?.nodeId || edge.target?.id || 'INVALID_TARGET';
                }
                
                const source = framework.nodes.find(n => n.id === sourceId);
                const target = framework.nodes.find(n => n.id === targetId);
                
                // Debug: Log missing node connections
                if (!source) {
                    console.warn(`⚠️ Edge ${edge.id} source node '${sourceId}' not found. Available nodes:`, framework.nodes.map(n => n.id).slice(0, 5));
                    return;
                }
                if (!target) {
                    console.warn(`⚠️ Edge ${edge.id} target node '${targetId}' not found. Available nodes:`, framework.nodes.map(n => n.id).slice(0, 5));
                    return;
                }
                
                // Debug: Log successful edge rendering (only first few to avoid spam)
                if (index < 3) {
                    console.log(`✅ Rendering edge ${edge.id}: ${source.name} → ${target.name}`);
                }
                edgesRendered++;
                
                const from = worldToScreen(source.position.x, source.position.y);
                const to = worldToScreen(target.position.x, target.position.y);
                
                // Determine edge style
                const isSelected = selectedEdge && selectedEdge === edge;
                const isConnectedToSelected = selectedNode && (edge.source === selectedNode.id || edge.target === selectedNode.id);
                const isHovered = hoveredEdge && hoveredEdge === edge;
                
                let strokeColor = '#444';
                let lineWidth = 1.5;
                
                if (isSelected) {
                    strokeColor = '#ff6b35';
                    lineWidth = 3;
                } else if (isConnectedToSelected) {
                    strokeColor = '#8b5cf6';
                    lineWidth = 2.5;
                } else if (isHovered) {
                    strokeColor = '#ff8555';
                    lineWidth = 2;
                }
                
                // Draw edge with enhanced styling
                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = lineWidth;
                
                // Add glow effect for selected/hovered edges
                if (isSelected || isHovered) {
                    ctx.shadowColor = strokeColor;
                    ctx.shadowBlur = 8;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                } else {
                    ctx.stroke();
                }
                
                // Draw arrow
                const angle = Math.atan2(to.y - from.y, to.x - from.x);
                const arrowSize = isSelected ? 12 : (isConnectedToSelected || isHovered ? 10 : 8);
                
                // Offset arrow to not overlap with node
                const nodeRadius = 20;
                const arrowOffset = nodeRadius + 5;
                const arrowX = to.x - arrowOffset * Math.cos(angle);
                const arrowY = to.y - arrowOffset * Math.sin(angle);
                
                ctx.beginPath();
                ctx.moveTo(arrowX, arrowY);
                ctx.lineTo(
                    arrowX - arrowSize * Math.cos(angle - Math.PI / 6),
                    arrowY - arrowSize * Math.sin(angle - Math.PI / 6)
                );
                ctx.lineTo(
                    arrowX - arrowSize * Math.cos(angle + Math.PI / 6),
                    arrowY - arrowSize * Math.sin(angle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fillStyle = strokeColor;
                ctx.fill();
                
                // Draw edge type label for selected/hovered edges
                if ((isSelected || isHovered) && edge.type && edge.type !== 'dependency') {
                    const midX = (from.x + to.x) / 2;
                    const midY = (from.y + to.y) / 2;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillRect(midX - 20, midY - 8, 40, 16);
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px -apple-system, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(edge.type, midX, midY + 3);
                }
            });
            
            // Draw nodes
            framework.nodes.forEach(node => {
                const screen = worldToScreen(node.position.x, node.position.y);
                const radius = 20; // Increased from 12 to 20
                const isSelected = selectedNode && selectedNode.id === node.id;
                
                // Node circle with glow effect
                ctx.beginPath();
                ctx.arc(screen.x, screen.y, radius, 0, Math.PI * 2);
                
                // Add glow for selected node
                if (isSelected) {
                    ctx.shadowColor = '#ff6b35';
                    ctx.shadowBlur = 20;
                }
                
                ctx.fillStyle = nodeColors[node.type] || nodeColors.default;
                ctx.fill();
                
                // Reset shadow
                ctx.shadowBlur = 0;
                
                // Selection ring
                if (isSelected) {
                    ctx.strokeStyle = '#ff6b35';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }
                
                // Label with better styling
                ctx.fillStyle = '#e0e0e0';
                ctx.font = 'bold 14px -apple-system, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(node.name.substring(0, 25), screen.x, screen.y + radius + 20);
            });
            
            // Draw edge creation preview
            if (isCreatingEdge && edgeCreationStart) {
                const startScreen = worldToScreen(edgeCreationStart.position.x, edgeCreationStart.position.y);
                
                // Get current mouse position for preview
                let mouseX = 0, mouseY = 0;
                canvas.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    mouseX = e.clientX - rect.left;
                    mouseY = e.clientY - rect.top;
                });
                
                ctx.beginPath();
                ctx.moveTo(startScreen.x, startScreen.y);
                ctx.lineTo(mouseX, mouseY);
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]); // Reset line dash
            }
            
            // Debug: Log rendering summary (occasionally)
            if (Math.random() < 0.01) { // 1% chance to log
                console.log(`📊 Rendered ${edgesRendered} edges and ${framework.nodes.length} nodes`);
            }
        }
        
        function animate() {
            // Apply gentle continuous physics
            const repulsionStrength = 8000;
            const attractionStrength = 0.001;
            const damping = 0.97;
            const minDistance = 250;
            
            // Apply gentle repulsion between all nodes
            for (let i = 0; i < framework.nodes.length; i++) {
                const nodeA = framework.nodes[i];
                
                for (let j = i + 1; j < framework.nodes.length; j++) {
                    const nodeB = framework.nodes[j];
                    
                    const dx = nodeB.position.x - nodeA.position.x;
                    const dy = nodeB.position.y - nodeA.position.y;
                    const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                    
                    if (distance < minDistance * 1.5) {
                        const force = repulsionStrength / (distance * distance + 100);
                        const fx = (dx / distance) * force;
                        const fy = (dy / distance) * force;
                        
                        nodeA.velocity.x -= fx * 0.005;
                        nodeA.velocity.y -= fy * 0.005;
                        nodeB.velocity.x += fx * 0.005;
                        nodeB.velocity.y += fy * 0.005;
                    }
                }
            }
            
            // Apply gentle attraction along edges
            framework.edges.forEach(edge => {
                // Safety check: Handle object sources/targets
                let sourceId = typeof edge.source === 'object' ? (edge.source?.nodeId || edge.source?.id) : edge.source;
                let targetId = typeof edge.target === 'object' ? (edge.target?.nodeId || edge.target?.id) : edge.target;
                
                const source = framework.nodes.find(n => n.id === sourceId);
                const target = framework.nodes.find(n => n.id === targetId);
                
                if (source && target) {
                    const dx = target.position.x - source.position.x;
                    const dy = target.position.y - source.position.y;
                    const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                    
                    const force = distance * attractionStrength;
                    const fx = (dx / distance) * force;
                    const fy = (dy / distance) * force;
                    
                    source.velocity.x += fx * 0.005;
                    source.velocity.y += fy * 0.005;
                    target.velocity.x -= fx * 0.005;
                    target.velocity.y -= fy * 0.005;
                }
            });
            
            // Update positions with damping
            framework.nodes.forEach(node => {
                node.position.x += node.velocity.x;
                node.position.y += node.velocity.y;
                node.velocity.x *= damping;
                node.velocity.y *= damping;
                
                // Add slight random wobble for organic movement
                node.velocity.x += (Math.random() - 0.5) * 0.02;
                node.velocity.y += (Math.random() - 0.5) * 0.02;
            });
            
            draw();
            requestAnimationFrame(animate);
        }
        
        // Enhanced formula parsing utility with spreadsheet syntax rejection
        class FormulaParser {
            static extractSymbols(formula) {
                if (!formula || typeof formula !== 'string') {
                    return [];
                }

                const cleanedFormula = formula
                    .replace(/\b(sin|cos|tan|log|ln|exp|sqrt|abs|min|max)\s*\(/g, '')
                    .replace(/[+\-*/^(){}[\],;=<>!&|]/g, ' ')
                    .replace(/\d+\.?\d*/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();

                const symbols = cleanedFormula
                    .split(' ')
                    .filter(symbol => symbol.length > 0 && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(symbol))
                    .filter((symbol, index, array) => array.indexOf(symbol) === index);

                return symbols;
            }

            static validateFormulaSymbols(formula, validNodeIds) {
                const symbols = this.extractSymbols(formula);
                const invalidSymbols = symbols.filter(symbol => !validNodeIds.includes(symbol));
                const validSymbols = symbols.filter(symbol => validNodeIds.includes(symbol));

                return {
                    isValid: invalidSymbols.length === 0,
                    invalidSymbols,
                    validSymbols,
                    allSymbols: symbols
                };
            }

            /**
             * Enhanced formula validation that rejects spreadsheet syntax and enforces mathematical modeling patterns
             */
            static validateMathematicalFormula(formula, nodeName = 'Node') {
                const errors = [];
                const warnings = [];

                if (!formula || typeof formula !== 'string') {
                    return { isValid: true, errors: [], warnings: [] };
                }

                const trimmedFormula = formula.trim();

                // Priority 1: Enhanced Pattern Detection - Reject spreadsheet syntax
                const spreadsheetPatterns = [
                    // Cell references: A1, G9, AA123, etc.
                    /\b[A-Z]+[0-9]+\b/g,
                    // Range syntax: G9:G22, A1:Z100, etc.
                    /\b[A-Z]+[0-9]+:[A-Z]+[0-9]+\b/g,
                    // Excel formulas starting with =
                    /^=/,
                    // Spreadsheet functions: SUM(), AVERAGE(), COUNT(), VLOOKUP(), etc.
                    /\b(SUM|AVERAGE|COUNT|VLOOKUP|HLOOKUP|INDEX|MATCH|IF|COUNTIF|SUMIF|MAX|MIN|STDEV|VAR)\s*\(/gi
                ];

                for (const pattern of spreadsheetPatterns) {
                    const matches = trimmedFormula.match(pattern);
                    if (matches) {
                        if (pattern.source === '^=') {
                            errors.push(`Formula starts with '=' which is spreadsheet syntax. Use mathematical expressions like 'REVENUE - COST' instead.`);
                        } else if (pattern.source.includes('[A-Z]+[0-9]+')) {
                            errors.push(`Formula contains cell references (${matches.join(', ')}). Use node identifiers like 'REVENUE' instead.`);
                        } else if (pattern.source.includes(':')) {
                            errors.push(`Formula contains range syntax (${matches.join(', ')}). Use individual node identifiers instead.`);
                        } else {
                            errors.push(`Formula contains spreadsheet function (${matches.join(', ')}). Use mathematical expressions instead.`);
                        }
                    }
                }

                // Priority 2: Stricter Symbol Extraction
                const validSymbols = this.extractMathematicalSymbols(trimmedFormula);
                const invalidSymbols = validSymbols.filter(symbol => this.isInvalidSymbol(symbol));

                if (invalidSymbols.length > 0) {
                    errors.push(`Formula contains invalid symbols: ${invalidSymbols.join(', ')}. Use meaningful node identifiers like 'REVENUE', 'COST', 'PROFIT' instead.`);
                }

                // Priority 3: Explicit Validation Rules
                const validationResult = this.validateMathematicalExpression(trimmedFormula);
                if (!validationResult.isValid) {
                    errors.push(...validationResult.errors);
                }

                return {
                    isValid: errors.length === 0,
                    errors,
                    warnings
                };
            }

            /**
             * Extract symbols from mathematical formulas, filtering out spreadsheet syntax
             */
            static extractMathematicalSymbols(formula) {
                if (!formula) return [];

                // Remove mathematical functions but keep their parentheses for proper parsing
                let cleanedFormula = formula
                    .replace(/\b(sin|cos|tan|log|ln|exp|sqrt|abs|min|max)\s*\(/g, '')
                    .replace(/[+\-*/^(){}[\],;=<>!&|]/g, ' ')
                    .replace(/\d+\.?\d*/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();

                // Extract potential symbols
                const symbols = cleanedFormula
                    .split(' ')
                    .filter(symbol => symbol.length > 0)
                    .filter(symbol => /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(symbol))
                    .filter((symbol, index, array) => array.indexOf(symbol) === index);

                return symbols;
            }

            /**
             * Check if a symbol is invalid (cell reference pattern)
             */
            static isInvalidSymbol(symbol) {
                // Reject cell reference patterns: letter(s) followed by number(s)
                return /^[A-Z]+[0-9]+$/.test(symbol);
            }

            /**
             * Validate mathematical expression structure
             */
            static validateMathematicalExpression(formula) {
                const errors = [];

                // Check for valid mathematical operators
                const validOperators = /[+\-*/^(){}[\]]/;
                const hasValidOperators = validOperators.test(formula);

                // Check for temporal references (e.g., REVENUE[0], COST[-1])
                const temporalPattern = /[a-zA-Z_][a-zA-Z0-9_]*\[-?\d+\]/g;
                const temporalMatches = formula.match(temporalPattern);

                // Check for basic mathematical structure
                if (!hasValidOperators && !temporalMatches && formula.length > 1) {
                    errors.push(`Formula appears to be a simple identifier. Use mathematical expressions like 'REVENUE - COST' or temporal references like 'REVENUE[0] - REVENUE[-1]'.`);
                }

                return {
                    isValid: errors.length === 0,
                    errors
                };
            }
        }
        
        // Edit Mode Management
        function toggleEditMode() {
            isEditMode = !isEditMode;
            const editBtn = document.getElementById('edit-mode-btn');
            const saveBtn = document.getElementById('save-btn');
            
            if (isEditMode) {
                editBtn.textContent = '👁️ View';
                editBtn.classList.add('active');
                saveBtn.style.display = 'block';
                document.body.classList.add('edit-mode');
                console.log('🔧 Edit mode enabled');
                showEditInstructions();
            } else {
                editBtn.textContent = '📝 Edit';
                editBtn.classList.remove('active');
                saveBtn.style.display = 'none';
                document.body.classList.remove('edit-mode');
                console.log('👁️ View mode enabled');
            }
        }
        
        // Auto-save functionality
        function scheduleAutoSave() {
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }
            
            autoSaveTimeout = setTimeout(() => {
                if (editedNodes.size > 0 || editedEdges.size > 0) {
                    saveChanges();
                }
            }, 3000); // Auto-save after 3 seconds of inactivity
        }
        
        function setSaveStatus(status, message = '') {
            const statusEl = document.getElementById('save-status');
            statusEl.className = `save-status ${status}`;
            statusEl.textContent = message;
        }
        
        async function saveChanges() {
            if (!isEditMode) return;
            
            setSaveStatus('saving', 'Saving...');
            
            try {
                // Create a graph diff with all changes
                const changes = {
                    nodes: Array.from(editedNodes.values()),
                    edges: Array.from(editedEdges.values())
                };
                
                console.log('💾 Saving changes:', changes);
                
                // TODO: Send to API using GraphDiffService
                // For now, just simulate success
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Clear tracked changes
                editedNodes.clear();
                editedEdges.clear();
                
                setSaveStatus('saved', 'Saved');
                setTimeout(() => setSaveStatus('', ''), 3000);
                
            } catch (error) {
                console.error('💥 Save failed:', error);
                setSaveStatus('error', 'Save failed');
            }
        }
        
        // Node editing functions
        function editNode(node) {
            if (!isEditMode) return;
            
            currentEditItem = { type: 'node', data: node };
            
            // Populate form
            document.getElementById('modal-title').textContent = node ? 'Edit Node' : 'Add Node';
            document.getElementById('edit-name').value = node?.name || '';
            document.getElementById('edit-type').value = node?.type || 'scalar';
            document.getElementById('edit-description').value = node?.metadata?.description || '';
            document.getElementById('edit-formula').value = node?.metadata?.formula || '';
            document.getElementById('edit-units').value = node?.metadata?.units || '';
            
            // Show modal
            document.getElementById('edit-modal').classList.add('show');
            
            // Set up real-time formula validation
            const formulaInput = document.getElementById('edit-formula');
            formulaInput.addEventListener('input', validateFormula);
            validateFormula(); // Initial validation
        }
        
        function validateFormula() {
            const formula = document.getElementById('edit-formula').value;
            const validationDiv = document.getElementById('formula-validation');
            
            if (!formula.trim()) {
                validationDiv.textContent = '';
                return true;
            }
            
            // Use enhanced mathematical formula validation
            const mathematicalValidation = FormulaParser.validateMathematicalFormula(formula);
            
            if (!mathematicalValidation.isValid) {
                // Show spreadsheet syntax errors
                validationDiv.innerHTML = `<span style="color: #ef4444;">✗ ${mathematicalValidation.errors.join('<br>')}</span>`;
                return false;
            }
            
            // If mathematical validation passes, check node references
            const validNodeIds = framework.nodes.map(n => n.id);
            const symbolValidation = FormulaParser.validateFormulaSymbols(formula, validNodeIds);
            
            if (symbolValidation.isValid) {
                validationDiv.innerHTML = symbolValidation.validSymbols.length > 0 
                    ? `<span style="color: #10b981;">✓ Valid references: ${symbolValidation.validSymbols.join(', ')}</span>`
                    : '<span style="color: #10b981;">✓ Formula syntax is valid</span>';
                return true;
            } else {
                validationDiv.innerHTML = `<span style="color: #ef4444;">✗ Invalid references: ${symbolValidation.invalidSymbols.join(', ')}</span>`;
                return false;
            }
        }
        
        function closeEditModal() {
            document.getElementById('edit-modal').classList.remove('show');
            currentEditItem = null;
        }
        
        function addNode(x, y) {
            if (!isEditMode) return;
            
            const worldPos = screenToWorld(x, y);
            const newNode = {
                id: `node_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                name: `Node_${framework.nodes.length + 1}`,
                type: 'scalar',
                position: { x: worldPos.x, y: worldPos.y, z: 0 },
                metadata: {}
            };
            
            editNode(newNode);
        }
        
        // Context menu functions
        function showContextMenu(x, y) {
            if (!isEditMode) return;
            
            contextMenuPosition = { x, y };
            const menu = document.getElementById('context-menu');
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.display = 'block';
        }
        
        function hideContextMenu() {
            document.getElementById('context-menu').style.display = 'none';
        }
        
        function editSelectedItem() {
            if (selectedNode) {
                editNode(selectedNode);
            } else if (selectedEdge) {
                // TODO: Implement edge editing
                console.log('Edge editing not yet implemented');
            }
            hideContextMenu();
        }
        
        function deleteSelectedItem() {
            if (!isEditMode) return;
            
            if (selectedNode) {
                // Remove node and associated edges
                framework.nodes = framework.nodes.filter(n => n.id !== selectedNode.id);
                framework.edges = framework.edges.filter(e => e.source !== selectedNode.id && e.target !== selectedNode.id);
                selectedNode = null;
                scheduleAutoSave();
            } else if (selectedEdge) {
                // Remove edge
                framework.edges = framework.edges.filter(e => e !== selectedEdge);
                selectedEdge = null;
                scheduleAutoSave();
            }
            
            hideContextMenu();
        }
        
        // Event listeners for edit mode
        document.getElementById('edit-mode-btn').addEventListener('click', toggleEditMode);
        document.getElementById('save-btn').addEventListener('click', saveChanges);
        
        // Form submission handler
        document.getElementById('edit-form').addEventListener('submit', function(e) {
            e.preventDefault();
            
            if (!validateFormula()) {
                alert('Please fix formula validation errors before saving.');
                return;
            }
            
            const formData = {
                name: document.getElementById('edit-name').value,
                type: document.getElementById('edit-type').value,
                description: document.getElementById('edit-description').value,
                formula: document.getElementById('edit-formula').value,
                units: document.getElementById('edit-units').value
            };
            
            if (currentEditItem?.type === 'node') {
                const node = currentEditItem.data;
                
                if (node.id) {
                    // Update existing node
                    const index = framework.nodes.findIndex(n => n.id === node.id);
                    if (index !== -1) {
                        framework.nodes[index].name = formData.name;
                        framework.nodes[index].type = formData.type;
                        framework.nodes[index].metadata = {
                            ...framework.nodes[index].metadata,
                            description: formData.description,
                            formula: formData.formula,
                            units: formData.units
                        };
                        
                        // Track for auto-save
                        editedNodes.set(node.id, framework.nodes[index]);
                    }
                } else {
                    // Add new node
                    const newNode = {
                        ...node,
                        name: formData.name,
                        type: formData.type,
                        metadata: {
                            description: formData.description,
                            formula: formData.formula,
                            units: formData.units
                        },
                        velocity: { x: 0, y: 0 }
                    };
                    
                    framework.nodes.push(newNode);
                    editedNodes.set(newNode.id, newNode);
                }
                
                // Always regenerate edges from formula (handles empty formulas too)
                generateEdgesFromFormula(formData.formula, node.id || currentEditItem.data.id);
                
                scheduleAutoSave();
            }
            
            closeEditModal();
        });
        
        // Enhanced edge generation from formula with comprehensive validation
        function generateEdgesFromFormula(formula, nodeId) {
            if (!formula || !formula.trim()) {
                // If formula is empty, remove all formula-generated edges for this node
                removeFormulaGeneratedEdges(nodeId);
                return;
            }

            // First validate the mathematical formula syntax
            const mathematicalValidation = FormulaParser.validateMathematicalFormula(formula);
            if (!mathematicalValidation.isValid) {
                console.warn(`⚠️ Cannot generate edges from invalid formula: ${mathematicalValidation.errors.join(', ')}`);
                // Remove existing formula-generated edges since formula is invalid
                removeFormulaGeneratedEdges(nodeId);
                return;
            }

            // Extract symbols using the enhanced parser
            const symbols = FormulaParser.extractMathematicalSymbols(formula);
            const validNodeIds = framework.nodes.map(n => n.id);
            
            // Extract temporal references (e.g., REVENUE[0], COST[-1])
            const temporalPattern = /([a-zA-Z_][a-zA-Z0-9_]*)\[(-?\d+)\]/g;
            const temporalReferences = [];
            let match;
            while ((match = temporalPattern.exec(formula)) !== null) {
                const nodeName = match[1];
                const timeOffset = parseInt(match[2]);
                if (validNodeIds.includes(nodeName)) {
                    temporalReferences.push({ nodeName, timeOffset });
                }
            }
            
            // Filter to only include symbols that reference existing nodes
            const validSymbols = symbols.filter(symbol => validNodeIds.includes(symbol));
            const invalidSymbols = symbols.filter(symbol => !validNodeIds.includes(symbol));

            if (invalidSymbols.length > 0) {
                console.warn(`⚠️ Formula references non-existent nodes: ${invalidSymbols.join(', ')}`);
            }

            // Remove existing formula-generated edges for this node
            removeFormulaGeneratedEdges(nodeId);

            // Create edges for regular dependencies and temporal references
            const edgesCreated = [];
            
            // Create dependency edges for regular symbol references
            validSymbols.forEach(symbolId => {
                // Check if edge already exists (manually created)
                const existingEdge = framework.edges.find(e => 
                    e.source === symbolId && 
                    e.target === nodeId && 
                    e.type === 'dependency'
                );

                if (!existingEdge) {
                    const edgeId = `edge_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    const newEdge = {
                        id: edgeId,
                        source: symbolId,
                        target: nodeId,
                        type: 'dependency',
                        metadata: {
                            generatedFromFormula: true,
                            formula: formula,
                            createdAt: new Date().toISOString()
                        }
                    };
                    
                    framework.edges.push(newEdge);
                    editedEdges.set(edgeId, newEdge);
                    edgesCreated.push(`dependency: ${symbolId}`);
                } else {
                    // Update existing edge metadata to reflect formula generation
                    existingEdge.metadata = {
                        ...existingEdge.metadata,
                        generatedFromFormula: true,
                        formula: formula,
                        updatedAt: new Date().toISOString()
                    };
                    editedEdges.set(existingEdge.id, existingEdge);
                    edgesCreated.push(`updated dependency: ${symbolId}`);
                }
            });

            // Create temporal edges for temporal references
            temporalReferences.forEach(({ nodeName, timeOffset }) => {
                const edgeId = `edge_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const temporalEdge = {
                    id: edgeId,
                    source: nodeName,
                    target: nodeId,
                    type: 'temporal',
                    metadata: {
                        generatedFromFormula: true,
                        formula: formula,
                        timeOffset: timeOffset,
                        createdAt: new Date().toISOString()
                    }
                };
                
                framework.edges.push(temporalEdge);
                editedEdges.set(edgeId, temporalEdge);
                edgesCreated.push(`temporal[${timeOffset}]: ${nodeName}`);
            });
            
            if (edgesCreated.length > 0) {
                console.log(`🔗 Generated ${edgesCreated.length} edges from formula: ${edgesCreated.join(', ')}`);
            } else {
                console.log(`ℹ️ No valid node references found in formula: "${formula}"`);
            }
        }

        // Helper function to remove formula-generated edges for a node
        function removeFormulaGeneratedEdges(nodeId) {
            const edgesToRemove = framework.edges.filter(e => 
                e.target === nodeId && 
                e.type === 'dependency' && 
                e.metadata?.generatedFromFormula
            );

            edgesToRemove.forEach(edge => {
                // Remove from framework.edges
                const index = framework.edges.findIndex(e => e.id === edge.id);
                if (index !== -1) {
                    framework.edges.splice(index, 1);
                }
                
                // Remove from editedEdges tracking
                editedEdges.delete(edge.id);
            });

            if (edgesToRemove.length > 0) {
                console.log(`🗑️ Removed ${edgesToRemove.length} formula-generated edges for node ${nodeId}`);
            }
        }
        
        // Hide context menu when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (!e.target.closest('#context-menu')) {
                hideContextMenu();
            }
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Only handle shortcuts if not typing in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            
            switch (e.key) {
                case 'Delete':
                case 'Backspace':
                    if (isEditMode) {
                        deleteSelectedItem();
                    }
                    break;
                    
                case 'Escape':
                    if (isCreatingEdge) {
                        isCreatingEdge = false;
                        edgeCreationStart = null;
                        canvas.style.cursor = isEditMode ? 'crosshair' : 'grab';
                    }
                    closeEditModal();
                    hideContextMenu();
                    break;
                    
                case 'e':
                case 'E':
                    if (!e.ctrlKey && !e.metaKey) {
                        toggleEditMode();
                    }
                    break;
                    
                case 's':
                case 'S':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        if (isEditMode) {
                            saveChanges();
                        }
                    }
                    break;
                    
                case 'n':
                case 'N':
                    if (isEditMode && !e.ctrlKey && !e.metaKey) {
                        // Add node at center of view
                        const centerX = canvas.offsetWidth / 2;
                        const centerY = canvas.offsetHeight / 2;
                        addNode(centerX, centerY);
                    }
                    break;
            }
        });
        
        // Add instructions for users
        function showEditInstructions() {
            if (isEditMode) {
                console.log(`
🔧 EDIT MODE ACTIVE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📝 Double-click node: Edit properties
📝 Double-click empty space: Add new node
🖱️ Right-click: Context menu
🔗 Shift+Click+Drag: Create edge between nodes
⌨️ Delete/Backspace: Delete selected item
⌨️ Escape: Cancel current operation
⌨️ Ctrl+S: Save changes
⌨️ E: Toggle edit mode
⌨️ N: Add node at center
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
                `);
            }
        }
        
        // Load on page load
        loadFramework();
    </script>
</body>
</html>
